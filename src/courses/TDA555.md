# TDA555 - Introduction to functional programming


## Looking up documentation

- How to hoogle
- When to hoogle
- Hackage, stackage

## Debugging in Haskell

The computer does what you tell it to do, not what you expect it to do. This 
truth has haunted computer programmers of every language, and Haskell is no 
exception. So how do you avoid bugs in Haskell, and how do you solve the ones 
you reach? Here are a few tips and tricks.

> **A note on print-debugging** 
> 
> In other languages, you might be used to the good old tactic of "print
> debugging", just sprinkle print statements in your code, and let it run. 
> This tactic is far, far less useful in Haskell. It exists, see 
> [this](https://hackage.haskell.org/package/base-4.16.2.0/docs/Debug-Trace.html).
> but it probably wont help you. This is the case since Haskell expressions 
> do not execute in a sequential fashion like in imperative languages, but rather
> are evaluated when, and if, it is needed.

### Let the compiler do the heavy lifting
Haskell has one of the most advanced and useful type systems out there. Use it
to your advantage! There are several ways for GHC to help you avoid bugs. 

**Supply types for your functions!**
Long before you start thinking about what steps your function
should take, you should figure out what type you want your function to have.
What does your input look like? And what does your output look like?
Just by doing this step, by telling Haskell what function you are planning on
writing you can avoid so many errors.

As an example, say that you're writing a function for reading the contents of a
file. And then want to use that function in `main`, and print the contents.
One might try to write something like this:
```haskell
getContents file = do
  contents <- readFile file
  putStrLn "Read file!"

main = do
  contents <- getContents "somefile.txt"
  print contents
```

[Task]
Can you tell what is wrong? What will get printed do you think?

[Solution]
`main` will always print `()`, since that is the result of the call to `putStrLn`
in `getContents`.

Now, had we gone about writing this function differently, by first figuring out
that, what we want getContents to return is an `IO String`, then the compiler
would have told us something was up.

```haskell
getContents :: FilePath -> IO String
getContents file = do
  contents <- readFile file
  putStrLn "Read file!"
```

```
Debug.hs:4:3: error:
    • Couldn't match type ‘()’ with ‘[Char]’
      Expected: IO String
        Actual: IO ()
    • In a stmt of a 'do' block: putStrLn "Read file"
      In the expression:
        do contents <- readFile file
           putStrLn "Read file"
      In an equation for ‘Main.getContents’:
          Main.getContents file
            = do contents <- readFile file
                 putStrLn "Read file"
  |
4 |   putStrLn "Read file"
  |   ^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
```

GHC is telling us that it expected a `IO String` but got a `IO ()`. Saying
*you haven't given me what you said you'd give me.*

With the knowledge that GHC will at least correct you when you supply the wrong
type. We can feel safer that this solution is correct:
```haskell
getContents :: FilePath -> IO String
getContents file = do
  contents <- readFile file
  putStrLn "Read file!"
  return contents
```

**Avoiding non-total functions** 
Pattern matching and recursion is the bread and butter of Haskell programming.
Though by default Haskell does not give an error whenever 

- Functions not doing what you assume they do
- Testing


## I enjoyed this course and want to learn more about Haskell
*Where do I go from here?*

- Advent of code
- Elective courses
- MPALG
